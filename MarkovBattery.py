import numpy as np

def create_birth_death_matrix(M, p_minus, p_plus):
    Q = np.zeros((M, M))  # Initialize a matrix of zeros

    # Setting the transition probabilities
    for i in range(M):
        if i > 0:
            Q[i, i - 1] = p_minus  # Death probability
        if i < M - 1:
            Q[i, i + 1] = p_plus  # Birth probability

        # Stay probability
        if i == 0:
            Q[i, i] = 1 - p_plus
        elif i == M - 1:
            Q[i, i] = 1 - p_minus
        else:
            Q[i, i] = 1 - p_minus - p_plus

    return Q

        
class EnergySystemSimulation:
    def __init__(self, M, Q, lambda_rate, C, B, e, alpha, time_step, total_time, eta_charge, eta_discharge):
        self.M = M
        self.Q = Q
        self.lambda_rate = lambda_rate
        self.C = C
        self.B = B
        self.e = e
        self.alpha = alpha
        self.time_step = time_step
        self.total_time = total_time
        self.current_state = np.random.choice(M)
        self.battery_level = 0
        self.peak_battery_needed = 0
        self.energy_bought = 0
        self.total_energy_required = 0
        self.time = 0
        self.eta_charge = eta_charge
        self.eta_discharge = eta_discharge
        self.energy_generated_total = 0

    def next_state(self):
        rates = -np.diag(self.Q)
        total_rate = rates[self.current_state]
        if total_rate <= 0:
            return self.current_state, self.time_step

        time_to_next_state = np.random.exponential(1 / total_rate)
        next_state_prob = self.Q[self.current_state] / total_rate
        next_state = np.random.choice(self.M, p=next_state_prob)
        return next_state, time_to_next_state

    def generate_job_energy_requirement(self):
        # Adjust the range of energy requirement to be more aligned with generation capacity
        return np.random.uniform(0, 2 * self.C)  # Example adjustment

    def simulate_step(self):
        next_state, time_to_next_state = self.next_state()
        self.time += min(time_to_next_state, self.time_step)
        self.current_state = next_state


        #calculates a proportion based on the current state 
        #(self.current_state) in the Markov chain. It divides the current state by (self.M - 1) 
        #to obtain a value between 0 and 1, representing the proportion of the maximum state reached in the Markov chain.
        #self.C: This proportion is then multiplied by the maximum generation capacity (self.C) 
        #to determine the energy generated. It assumes that the energy generated is proportional to the state in the Markov chain, 
        #where a higher state results in more energy generated.
        
        #represents the amount of energy produced or generated by the energy system in the current state of the 
        #Markov chain during a single step of the simulation.
        '''    self.current_state: This variable stores the current state of the Markov chain. 
                It represents the state of the energy system, which can vary from 0 to self.M - 1.
    (self.M - 1): This is the maximum possible state value in the Markov chain. It's used to normalize the current state to a value between 0 and 1.
    self.C: This represents the maximum generation capacity of the energy source.

    The calculation essentially scales the current state (self.current_state) to a value between 0 and 1 by dividing it by the maximum state value (self.M - 1). 
    Then, it multiplies this scaled value by the maximum generation capacity (self.C) to determine the amount of energy generated.
    '''
        energy_generated = (self.current_state / (self.M - 1)) * self.C  # Proportional to the state
        energy_required = self.generate_job_energy_requirement()
        self.total_energy_required += energy_required

        
        if energy_generated < energy_required:
            deficit = energy_required - energy_generated
            effective_deficit = deficit / self.eta_discharge  # Adjust for discharge efficiency
            if self.battery_level >= effective_deficit:
                self.battery_level -= effective_deficit
            
            else:
                if self.alpha > 0:
                    max_external_energy = self.alpha * self.total_energy_required
                    energy_to_buy = min(deficit - self.battery_level, max_external_energy - self.energy_bought)
                    self.energy_bought += energy_to_buy
                    effective_deficit -= energy_to_buy
                self.peak_battery_needed = max(self.peak_battery_needed, effective_deficit)
                self.battery_level = 0
        
        else:
            chargeable_energy = min(self.B - self.battery_level, 
                                    self.eta_charge * (energy_generated - energy_required))
            self.battery_level += chargeable_energy
    
    def run_simulation(self):
        while self.time < self.total_time:
            self.simulate_step()

        return self.peak_battery_needed
    
    def calculate_achieved_alpha(self):
        if self.total_energy_required > 0:
            achieved_alpha = min(self.energy_bought / self.total_energy_required, self.alpha)
            return max(0, achieved_alpha)  # Ensuring alpha is within [0, alpha]
        else:
            return 0


def main():
    eta_charge = 0.85   # Example charge efficiency
    eta_discharge = 0.75 # Example discharge efficiency
    p_minus = 0.2
    p_plus = 0.3
    C = 9.999  # Maximum capacity
    M = 5     # Number of states in the Markov chain
    B = 100   # Starting with a maximum battery capacity
    e = 0.8   # Efficiency of battery storage
    lambda_rate = 0.2
    time_step = 1
    total_time = 2000
    alphas = [0, 0.01, 0.05, 0.1]

    # Create the birth-death matrix
    Q = create_birth_death_matrix(M, p_minus, p_plus)

    for alpha in alphas:
        simulation = EnergySystemSimulation(M, Q, lambda_rate, C, B, e, alpha, time_step, total_time, eta_charge, eta_discharge)
        min_battery_capacity = simulation.run_simulation()
        achieved_alpha = simulation.calculate_achieved_alpha()
        print(f"Minimum Capacity for a={alpha}: {min_battery_capacity} Wh, Achieved alpha: {achieved_alpha:.2f}")

if __name__ == "__main__":
    main()


'''
The use of states in this simulation represents different levels or conditions of the energy system. 
The energy system is modeled as a Markov chain with multiple states, and each state corresponds to a particular configuration or condition of the system. 
Here's why states are used:

    Modeling Variability: In real-world energy systems, various factors can affect the energy production or availability. 
    These factors can include weather conditions, equipment performance, and other external influences. 
    By using different states, the simulation can capture the variability in energy production based on the current state of the system.

    State Transitions: The Markov chain defines transition probabilities between states. 
    This means that the energy system can transition from one state to another over time. 
    For example, a sunny day might lead to a higher state with more energy production, while a cloudy day might lead to a lower state with less production. 
    These transitions are probabilistic and capture the stochastic nature of energy systems.

    Proportional Energy Generation: The energy generation in each state is proportional to the state itself. 
    This reflects the idea that, in some energy systems, the capacity or efficiency of energy generation can vary based on the system's condition.
    States allow the simulation to reflect this proportionality, where higher states result in more energy production.

In summary, the use of states in the simulation is a way to model the dynamic and probabilistic nature of energy systems. 
It allows the simulation to capture how energy production varies over time and in response to different conditions, making it a more realistic representation of real-world energy systems.'''
